name: "Deployment Notification"
description: "Extract Jira tickets and send Slack notifications for deployments"
inputs:
  repo:
    description: "Repository name (e.g., Mito, Injective)"
    required: true
  network:
    description: "Network name for the deployment"
    required: true
  description:
    description: "Description of the deployment"
    required: false
    default: "Frontend deployment"
  slack-user-token:
    description: "Slack user token for reading messages"
    required: true
  slack-bot-token:
    description: "Slack bot token for sending messages"
    required: true
  staging_url:
    description: "URL of the staging deployment"
    required: true
  slack-channel:
    description: "Slack channel name for notifications"
    required: false
    default: "frontend-staging"

outputs:
  branch_name:
    description: "The branch name that was deployed"
    value: ${{ steps.branch_name.outputs.branch_name }}
  jira_tickets:
    description: "Comma-separated list of Jira tickets found"
    value: ${{ steps.jira_tickets.outputs.jira_tickets }}
  jira_links:
    description: "Formatted Jira links for Slack"
    value: ${{ steps.jira_tickets.outputs.jira_links }}
  message_found:
    description: "Whether an existing Slack message was found"
    value: ${{ steps.check_slack.outputs.message_found }}
  existing_message_ts:
    description: "Timestamp of existing Slack message if found"
    value: ${{ steps.check_slack.outputs.existing_message_ts }}
  existing_channel_id:
    description: "Channel ID of existing Slack message if found"
    value: ${{ steps.check_slack.outputs.existing_channel_id }}
  existing_jira_tickets:
    description: "Jira tickets from existing Slack message"
    value: ${{ steps.check_slack.outputs.existing_jira_tickets }}
  existing_message_text_b64:
    description: "Base64 encoded existing message text"
    value: ${{ steps.check_slack.outputs.existing_message_text_b64 }}
  channel_name:
    description: "Slack channel name used"
    value: ${{ steps.check_slack.outputs.channel_name }}
  message_ts:
    description: "Timestamp of the Slack message (either existing or newly created)"
    value: ${{ steps.slack_notification.outputs.message_ts }}
runs:
  using: composite
  steps:
    - name: Get branch name
      id: branch_name
      shell: bash
      run: |
        # Get branch name from workflow_dispatch input
        BRANCH_NAME="${{ github.event.inputs.branch }}"
        echo "üéØ Using specified branch: $BRANCH_NAME"

        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        echo "channel_name=${{ inputs.slack-channel }}" >> $GITHUB_OUTPUT

    - name: Extract Jira tickets from commits
      id: jira_tickets
      shell: bash
      run: |
        echo "üîç Extracting Jira ticket references from commits..."

        # Get commit messages from the current branch
        BRANCH_NAME="${{ steps.branch_name.outputs.branch_name }}"
        echo "üåø Scanning commits on current branch: $BRANCH_NAME"

        # First, fetch the latest origin/dev to ensure we have the most recent reference
        echo "üîÑ Fetching latest origin/dev for comparison..."
        git fetch origin dev 2>/dev/null || echo "‚ö†Ô∏è Could not fetch origin/dev, proceeding with local reference"

        # Get only the NEW commits that are different from origin/dev
        COMMIT_MESSAGES=$(git log origin/dev..HEAD --oneline 2>/dev/null || echo "")
        COMMIT_COUNT=$(git rev-list --count origin/dev..HEAD 2>/dev/null || echo "0")
        echo "üìä Found $COMMIT_COUNT NEW commits on current branch (compared to origin/dev)"

        echo "üìù Analyzing commit messages..."
        echo "üìã Commit messages being analyzed:"
        echo "----------------------------------------"
        if [ -n "$COMMIT_MESSAGES" ]; then
          echo "$COMMIT_MESSAGES"
        else
          echo "No commit messages found"
        fi
        echo "----------------------------------------"

        # Extract all IL patterns using grep with regex (hardcoded for Injective Labs)
        JIRA_MATCHES=$(echo "$COMMIT_MESSAGES" | grep -ioE '(IL|il)-[0-9]{3,5}' | sort | uniq -i || true)

        if [ -z "$JIRA_MATCHES" ]; then
          echo "üìã No Jira tickets found in commits"
          echo "jira_tickets=" >> $GITHUB_OUTPUT
          echo "jira_links=" >> $GITHUB_OUTPUT
        else
          echo "üé´ Found Jira ticket patterns:"
          echo "$JIRA_MATCHES"
          
          # Convert to uppercase and deduplicate
          UNIQUE_TICKETS=$(echo "$JIRA_MATCHES" | tr '[:lower:]' '[:upper:]' | sort | uniq)
          
          echo "‚úÖ Unique tickets (normalized):"
          echo "$UNIQUE_TICKETS"
          
          # Generate Jira links (hardcoded for Injective Labs)
          JIRA_LINKS=""
          TICKET_LIST=""
          
          for ticket in $UNIQUE_TICKETS; do
            JIRA_URL="https://injective-labs.atlassian.net/browse/$ticket"
            if [ -z "$JIRA_LINKS" ]; then
              JIRA_LINKS="<$JIRA_URL|$ticket>"
              TICKET_LIST="$ticket"
            else
              JIRA_LINKS="$JIRA_LINKS, <$JIRA_URL|$ticket>"
              TICKET_LIST="$TICKET_LIST, $ticket"
            fi
          done
          
          echo "üîó Generated Jira links: $JIRA_LINKS"
          echo "jira_tickets=$TICKET_LIST" >> $GITHUB_OUTPUT
          echo "jira_links=$JIRA_LINKS" >> $GITHUB_OUTPUT
        fi

    - name: Check for existing Slack message
      id: check_slack
      shell: bash
      run: |
        # Hybrid approach: Use user token to READ messages, bot token to SEND messages
        BRANCH_NAME="${{ steps.branch_name.outputs.branch_name }}"
        CHANNEL_NAME="${{ inputs.slack-channel }}"

        echo "üîç Searching for existing messages for branch: $BRANCH_NAME"

        # Calculate date 30 days ago for search limitation
        THIRTY_DAYS_AGO=$(date -d "30 days ago" '+%Y-%m-%d' 2>/dev/null || date -v-30d '+%Y-%m-%d')

        # Use USER TOKEN for searching messages (has read access) with 30-day limit
        # Search for parent messages by repo and branch name - each repo+branch combination gets its own deployment thread
        REPO_NAME="${{ inputs.repo }}"
        SEARCH_QUERY="in:#$CHANNEL_NAME \"$REPO_NAME\" \"$BRANCH_NAME\" after:$THIRTY_DAYS_AGO"

        echo "üîç Search query: $SEARCH_QUERY"

        RESPONSE=$(curl -s -X POST \
          -H "Authorization: Bearer ${{ inputs.slack-user-token }}" \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "query=$SEARCH_QUERY&count=10&sort=timestamp" \
          "https://slack.com/api/search.messages")

        echo "üîç Search response status: $(echo "$RESPONSE" | jq -r '.ok // "unknown"')"
        echo "üîç Search response: $(echo "$RESPONSE" | jq -r '.messages.total // "unknown"') total messages found"


        # Check if search was successful
        if echo "$RESPONSE" | jq -e '.ok == true' > /dev/null; then
          # Extract message timestamp and channel ID if found
          MESSAGE_TS=$(echo "$RESPONSE" | jq -r '.messages.matches[0].ts // empty')
          CHANNEL_ID=$(echo "$RESPONSE" | jq -r '.messages.matches[0].channel.id // empty')
          
          if [ -n "$MESSAGE_TS" ] && [ "$MESSAGE_TS" != "null" ]; then
            echo "‚úÖ Found existing message with timestamp: $MESSAGE_TS"
            echo "üßµ Will thread new deployment to existing message"
            
            # Extract Jira tickets from the existing message to avoid duplicates
            EXISTING_MESSAGE_TEXT=$(echo "$RESPONSE" | jq -r '.messages.matches[0].text // empty')
            EXISTING_JIRA_TICKETS=""
            
            if [ -n "$EXISTING_MESSAGE_TEXT" ]; then
              # Extract IL patterns from existing message text (handles both plain text and Slack link format)
              EXISTING_JIRA_TICKETS=$(echo "$EXISTING_MESSAGE_TEXT" | grep -ioE 'IL-[0-9]{3,5}' | tr '[:lower:]' '[:upper:]' | sort | uniq | tr '\n' ',' | sed 's/,$//' || true)
              
              if [ -n "$EXISTING_JIRA_TICKETS" ]; then
                echo "üìã Existing message contains Jira tickets: $EXISTING_JIRA_TICKETS"
              else
                echo "üìã No Jira tickets found in existing message"
              fi
            fi
            
            # Fetch ALL messages in the thread to get complete Jira ticket history
            # This ensures we check against tickets mentioned ANYWHERE in the thread (not just original message)
            echo "üßµ Fetching all messages in thread to get complete ticket history..."
            THREAD_RESPONSE=$(curl -s -X GET \
              -H "Authorization: Bearer ${{ inputs.slack-user-token }}" \
              "https://slack.com/api/conversations.replies?channel=$CHANNEL_ID&ts=$MESSAGE_TS")
            
            ALL_THREAD_JIRA_TICKETS=""
            
            if echo "$THREAD_RESPONSE" | jq -e '.ok == true' > /dev/null; then
              # Extract all message texts from the thread
              ALL_THREAD_MESSAGES=$(echo "$THREAD_RESPONSE" | jq -r '.messages[].text // empty' | tr '\n' ' ')
              
              # Extract IL patterns from ALL thread messages
              ALL_THREAD_JIRA_TICKETS=$(echo "$ALL_THREAD_MESSAGES" | grep -ioE 'IL-[0-9]{3,5}' | tr '[:lower:]' '[:upper:]' | sort | uniq | tr '\n' ',' | sed 's/,$//' || true)
              
              if [ -n "$ALL_THREAD_JIRA_TICKETS" ]; then
                echo "üìã Complete thread Jira ticket history: $ALL_THREAD_JIRA_TICKETS"
              else
                echo "üìã No Jira tickets found in entire thread"
              fi
              
              # Also extract the original message text for updating later
              ORIGINAL_MESSAGE_TEXT=$(echo "$THREAD_RESPONSE" | jq -r '.messages[0].text // empty')
              ORIGINAL_MESSAGE_TEXT_B64=$(echo "$ORIGINAL_MESSAGE_TEXT" | base64 -w 0)
            else
              echo "‚ö†Ô∏è Failed to fetch thread messages, falling back to original message only"
              ALL_THREAD_JIRA_TICKETS="$EXISTING_JIRA_TICKETS"
              ORIGINAL_MESSAGE_TEXT_B64=$(echo "$EXISTING_MESSAGE_TEXT" | base64 -w 0)
            fi
            
            echo "existing_message_ts=$MESSAGE_TS" >> $GITHUB_OUTPUT
            echo "existing_channel_id=$CHANNEL_ID" >> $GITHUB_OUTPUT
            echo "existing_jira_tickets=$ALL_THREAD_JIRA_TICKETS" >> $GITHUB_OUTPUT
            echo "existing_message_text_b64=$ORIGINAL_MESSAGE_TEXT_B64" >> $GITHUB_OUTPUT
            echo "message_found=true" >> $GITHUB_OUTPUT
          else
            echo "üìù No existing message found for branch: $BRANCH_NAME"
            echo "üÜï Will create new message"
            echo "message_found=false" >> $GITHUB_OUTPUT
            echo "existing_channel_id=" >> $GITHUB_OUTPUT
            echo "existing_jira_tickets=" >> $GITHUB_OUTPUT
            echo "existing_message_text_b64=" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå Search API failed, will create new message"
          echo "message_found=false" >> $GITHUB_OUTPUT
          echo "existing_channel_id=" >> $GITHUB_OUTPUT
          echo "existing_jira_tickets=" >> $GITHUB_OUTPUT
          echo "existing_message_text_b64=" >> $GITHUB_OUTPUT
        fi

    - name: Send Slack notification
      if: always()
      id: slack_notification
      shell: bash
      run: |
        # Disable exit on error to prevent CI failure
        set +e

        BRANCH_NAME="${{ steps.branch_name.outputs.branch_name }}"

        # Use inputs for network and description
        NETWORK="${{ inputs.network }}"
        DESCRIPTION="${{ inputs.description }}"

        AUTHOR="${{ github.actor }}"
        CHANNEL_NAME="${{ steps.branch_name.outputs.channel_name }}"
        JIRA_LINKS="${{ steps.jira_tickets.outputs.jira_links }}"
        JIRA_TICKETS="${{ steps.jira_tickets.outputs.jira_tickets }}"
        EXISTING_JIRA_TICKETS="${{ steps.check_slack.outputs.existing_jira_tickets }}"

        echo "üì¢ Posting deployment notification to #$CHANNEL_NAME"

        if [ "${{ steps.check_slack.outputs.message_found }}" = "true" ]; then
          # Thread to existing message AND potentially update main message with new tickets
          MESSAGE_TS="${{ steps.check_slack.outputs.existing_message_ts }}"
          echo "üßµ Threading to existing message (timestamp: $MESSAGE_TS)"
          
          # Check if we have NEW Jira tickets to add to the main message
          NEW_TICKETS_FOR_MAIN=""
          if [ -n "$JIRA_TICKETS" ]; then
            echo "üîç Checking for new Jira tickets against thread history..."
            
            # Convert comma-separated ticket lists to arrays for comparison
            IFS=', ' read -ra CURRENT_ARRAY <<< "$JIRA_TICKETS"
            IFS=', ' read -ra EXISTING_ARRAY <<< "$EXISTING_JIRA_TICKETS"
            
            for ticket in "${CURRENT_ARRAY[@]}"; do
              ticket=$(echo "$ticket" | xargs)
              
              # Check if this ticket is NOT in the existing tickets
              FOUND_IN_EXISTING=false
              for existing_ticket in "${EXISTING_ARRAY[@]}"; do
                existing_ticket=$(echo "$existing_ticket" | xargs)
                if [ "$ticket" = "$existing_ticket" ]; then
                  FOUND_IN_EXISTING=true
                  break
                fi
              done
              
              if [ "$FOUND_IN_EXISTING" = "false" ]; then
                echo "‚úÖ New ticket found for main message: $ticket"
                if [ -z "$NEW_TICKETS_FOR_MAIN" ]; then
                  NEW_TICKETS_FOR_MAIN="$ticket"
                else
                  NEW_TICKETS_FOR_MAIN="$NEW_TICKETS_FOR_MAIN, $ticket"
                fi
              fi
            done
          fi
          
          # Update main message if we have new tickets or new staging URL
          if [ -n "$NEW_TICKETS_FOR_MAIN" ] || [ -n "${{ inputs.staging_url }}" ]; then
            echo "üìù Updating main message to add new tickets: $NEW_TICKETS_FOR_MAIN and staging URL: ${{ inputs.staging_url }}"
            
            # Use the original message text we extracted from the thread response
            # Decode the base64 encoded message text from the previous step
            echo "üîß Decoding base64 message text..."
            CURRENT_MAIN_TEXT=$(echo "${{ steps.check_slack.outputs.existing_message_text_b64 }}" | base64 -d 2>/dev/null || echo "")
            
            if [ -n "$CURRENT_MAIN_TEXT" ] && [ "$CURRENT_MAIN_TEXT" != "null" ]; then
              echo "üìÑ Using original message text from thread response"
              
              # Set up error handling for text processing
              set +e  # Disable exit on error for this section
              UPDATED_MAIN_TEXT="$CURRENT_MAIN_TEXT"
              
              # Handle Jira tickets if we have new ones
              if [ -n "$NEW_TICKETS_FOR_MAIN" ]; then
                echo "üîß Processing Jira tickets: $NEW_TICKETS_FOR_MAIN"
                # Generate new ticket links
                NEW_JIRA_LINKS=""
                IFS=', ' read -ra NEW_TICKETS_ARRAY <<< "$NEW_TICKETS_FOR_MAIN"
                for ticket in "${NEW_TICKETS_ARRAY[@]}"; do
                  ticket=$(echo "$ticket" | xargs)
                  JIRA_URL="https://injective-labs.atlassian.net/browse/$ticket"
                  if [ -z "$NEW_JIRA_LINKS" ]; then
                    NEW_JIRA_LINKS="<$JIRA_URL|$ticket>"
                  else
                    NEW_JIRA_LINKS="$NEW_JIRA_LINKS, <$JIRA_URL|$ticket>"
                  fi
                done
                
                echo "üîß Generated Jira links: $NEW_JIRA_LINKS"
                
                # Check if the main message already has Jira tickets section
                if echo "$UPDATED_MAIN_TEXT" | grep -q "Jira tickets:"; then
                  echo "üîß Found existing Jira tickets section, appending..."
                  # Append to existing Jira tickets line (add at the end)
                  # Use a more specific pattern to match the Jira tickets line
                  TEMP_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed "s#\(\*Jira tickets:\* [^\\n]*\)#\1, $NEW_JIRA_LINKS#" 2>/dev/null || echo "$UPDATED_MAIN_TEXT")
                  if [ "$TEMP_TEXT" != "$UPDATED_MAIN_TEXT" ]; then
                    UPDATED_MAIN_TEXT="$TEMP_TEXT"
                    echo "üìù Appending to existing Jira tickets section"
                  else
                    echo "‚ö†Ô∏è Failed to append to Jira tickets, adding new section instead"
                    UPDATED_MAIN_TEXT="$UPDATED_MAIN_TEXT\n*Jira tickets:* $NEW_JIRA_LINKS"
                  fi
                else
                  # Add new Jira tickets section
                  UPDATED_MAIN_TEXT="$UPDATED_MAIN_TEXT\n*Jira tickets:* $NEW_JIRA_LINKS"
                  echo "üìù Adding new Jira tickets section"
                fi
              fi
              
              # Handle staging URLs if provided
              if [ -n "${{ inputs.staging_url }}" ]; then
                NEW_STAGING_URL="${{ inputs.staging_url }}"
                echo "üîß Processing staging URL: $NEW_STAGING_URL"
                
                # Check if the main message already has Staging URLs section
                if echo "$UPDATED_MAIN_TEXT" | grep -q "Staging URLs:"; then
                  echo "üîß Found existing Staging URLs section"
                  # Check if it's in list format (with dashes) or single URL format
                  if echo "$UPDATED_MAIN_TEXT" | grep -q "Staging URLs:\n-"; then
                    echo "üîß Appending to existing list format..."
                    # Already in list format, append new URL
                    TEMP_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed "s#\(Staging URLs:.*\)#\1\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>#" 2>/dev/null || echo "$UPDATED_MAIN_TEXT")
                    if [ "$TEMP_TEXT" != "$UPDATED_MAIN_TEXT" ]; then
                      UPDATED_MAIN_TEXT="$TEMP_TEXT"
                      echo "üìù Appending to existing Staging URLs list"
                    else
                      echo "‚ö†Ô∏è Failed to append to list, adding new section instead"
                      UPDATED_MAIN_TEXT="$UPDATED_MAIN_TEXT\n*Staging URLs:*\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>"
                    fi
                  else
                    echo "üîß Converting single URL to list format..."
                    # Single URL format, convert to list format
                    # Extract existing URL and convert to list format
                    # Handle both Slack link format and plain URL format
                    EXISTING_URL=""
                    if echo "$UPDATED_MAIN_TEXT" | grep -q "Staging URLs: <"; then
                      # Slack link format
                      EXISTING_URL=$(echo "$UPDATED_MAIN_TEXT" | grep -o "Staging URLs: <[^>]*|.*>" | sed 's/Staging URLs: <\([^|]*\)|.*>/\1/' 2>/dev/null || echo "")
                    else
                      # Plain URL format
                      EXISTING_URL=$(echo "$UPDATED_MAIN_TEXT" | grep -o "Staging URLs: https://[^[:space:]]*" | sed 's/Staging URLs: //' 2>/dev/null || echo "")
                    fi
                    
                    if [ -n "$EXISTING_URL" ]; then
                      echo "üîß Found existing URL: $EXISTING_URL"
                      # Replace single URL with list format - put "Staging URLs:" on its own line
                      if echo "$UPDATED_MAIN_TEXT" | grep -q "Staging URLs: <"; then
                        # Replace Slack link format - match only the first occurrence on the line
                        TEMP_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed "s#Staging URLs: <[^>]*|.*>#Staging URLs:\n- <$EXISTING_URL|$EXISTING_URL>\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>#" 2>/dev/null || echo "$UPDATED_MAIN_TEXT")
                      else
                        # Replace plain URL format - be more specific to match only the first URL on the line
                        # Use a more precise pattern that stops at the first space or newline after the URL
                        TEMP_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed "s#Staging URLs: https://[^[:space:]]*#Staging URLs:\n- <$EXISTING_URL|$EXISTING_URL>\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>#" 2>/dev/null || echo "$UPDATED_MAIN_TEXT")
                      fi
                      
                      if [ "$TEMP_TEXT" != "$UPDATED_MAIN_TEXT" ]; then
                        UPDATED_MAIN_TEXT="$TEMP_TEXT"
                        echo "üìù Converting single Staging URL to list format and adding new URL"
                      else
                        echo "‚ö†Ô∏è Failed to convert to list, adding new section instead"
                        UPDATED_MAIN_TEXT="$UPDATED_MAIN_TEXT\n*Staging URLs:*\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>"
                      fi
                    else
                      echo "üîß Fallback: appending to existing section..."
                      # Fallback: just append as list - put "Staging URLs:" on its own line
                      # Use a more specific pattern to avoid matching already formatted lists
                      if echo "$UPDATED_MAIN_TEXT" | grep -q "Staging URLs: https://"; then
                        # This is a single URL format, convert it properly
                        # Extract the existing URL first
                        EXISTING_URL_SIMPLE=$(echo "$UPDATED_MAIN_TEXT" | grep -o "Staging URLs: https://[^[:space:]]*" | sed 's/Staging URLs: //')
                        if [ -n "$EXISTING_URL_SIMPLE" ]; then
                          # Replace the single URL with proper list format
                          TEMP_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed "s#Staging URLs: $EXISTING_URL_SIMPLE#Staging URLs:\n- <$EXISTING_URL_SIMPLE|$EXISTING_URL_SIMPLE>\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>#")
                        else
                          # Fallback: just append
                          TEMP_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed "s#\(Staging URLs:.*\)#\1\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>#" 2>/dev/null || echo "$UPDATED_MAIN_TEXT")
                        fi
                      else
                        # Already in list format, just append
                        TEMP_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed "s#\(Staging URLs:.*\)#\1\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>#" 2>/dev/null || echo "$UPDATED_MAIN_TEXT")
                      fi
                      
                      if [ "$TEMP_TEXT" != "$UPDATED_MAIN_TEXT" ]; then
                        UPDATED_MAIN_TEXT="$TEMP_TEXT"
                        echo "üìù Appending to Staging URLs section"
                      else
                        echo "‚ö†Ô∏è Failed to append, adding new section instead"
                        UPDATED_MAIN_TEXT="$UPDATED_MAIN_TEXT\n*Staging URLs:*\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>"
                      fi
                    fi
                  fi
                else
                  # Add new Staging URLs section
                  UPDATED_MAIN_TEXT="$UPDATED_MAIN_TEXT\n*Staging URLs:*\n- <$NEW_STAGING_URL|$NEW_STAGING_URL>"
                  echo "üìù Adding new Staging URLs section"
                fi
              fi
              
              # Re-enable exit on error
              set -e
              
              # Update the main message using channel ID (required for chat.update API)
              CHANNEL_ID="${{ steps.check_slack.outputs.existing_channel_id }}"
              
              # Escape the message text properly for JSON
              echo "üîß Escaping message text for JSON..."
              ESCAPED_MAIN_TEXT=$(echo "$UPDATED_MAIN_TEXT" | sed 's/"/\\"/g' | sed 's/\\n/\\n/g' 2>/dev/null || echo "$UPDATED_MAIN_TEXT")
              
              echo "üîß Attempting to update main message..."
              echo "üìù Message length: $(echo "$ESCAPED_MAIN_TEXT" | wc -c) characters"
              UPDATE_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${{ inputs.slack-bot-token }}" \
                -H "Content-type: application/json" \
                -d "{
                  \"channel\": \"$CHANNEL_ID\",
                  \"ts\": \"$MESSAGE_TS\",
                  \"text\": \"$ESCAPED_MAIN_TEXT\"
                }" \
                "https://slack.com/api/chat.update")
              
              UPDATE_SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.ok // false')
              if [ "$UPDATE_SUCCESS" = "true" ]; then
                echo "‚úÖ Successfully updated main message with new tickets: $NEW_JIRA_LINKS"
              else
                UPDATE_ERROR=$(echo "$UPDATE_RESPONSE" | jq -r '.error // "unknown"')
                echo "‚ö†Ô∏è Failed to update main message: $UPDATE_ERROR"
                echo "üìã Update response: $UPDATE_RESPONSE"
                # Don't fail the entire step if message update fails
                echo "üîÑ Continuing with thread message despite update failure..."
              fi
            else
              echo "‚ö†Ô∏è Could not retrieve original message text from thread response"
            fi
          else
            echo "üìã No new tickets to add to main message, skipping update"
          fi
          
          # Create threaded reply with deployment details (no Jira tickets since they're in main message)
          THREAD_MESSAGE_TEXT="üîÑ *New staging link deployed ($NETWORK)*"
          
          if [ -n "$DESCRIPTION" ]; then
            THREAD_MESSAGE_TEXT="$THREAD_MESSAGE_TEXT\n*Description:* $DESCRIPTION"
          fi
          
          # Add staging URL if provided
          if [ -n "${{ inputs.staging_url }}" ]; then
            THREAD_MESSAGE_TEXT="$THREAD_MESSAGE_TEXT\n*Staging URL:* <${{ inputs.staging_url }}|${{ inputs.staging_url }}>"
          fi
          
          THREAD_MESSAGE_TEXT="$THREAD_MESSAGE_TEXT\n*Author:* $AUTHOR"
          
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ inputs.slack-bot-token }}" \
            -H "Content-type: application/json" \
            -d "{
              \"channel\": \"#$CHANNEL_NAME\",
              \"thread_ts\": \"$MESSAGE_TS\",
              \"text\": \"$THREAD_MESSAGE_TEXT\"
            }" \
            "https://slack.com/api/chat.postMessage")
          
          # For existing messages, use the existing message timestamp
          FINAL_MESSAGE_TS="$MESSAGE_TS"
        else
          # Create new message
          echo "üÜï Creating new deployment message"
          
          # Build message with optional Jira links (no network in body)
          MESSAGE_TEXT="*${{ inputs.repo }}* - Staging Deployment ($NETWORK)\n\n*Branch:* \`$BRANCH_NAME\`\n*Description:* $DESCRIPTION"
          
          # Add staging URL if provided
          if [ -n "${{ inputs.staging_url }}" ]; then
            MESSAGE_TEXT="$MESSAGE_TEXT\n*Staging URLs:*\n- <${{ inputs.staging_url }}|${{ inputs.staging_url }}>"
          fi
          
          MESSAGE_TEXT="$MESSAGE_TEXT\n*Author:* $AUTHOR"
          
          if [ -n "$JIRA_LINKS" ]; then
            MESSAGE_TEXT="$MESSAGE_TEXT\n*Jira tickets:* $JIRA_LINKS"
          fi
          
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ inputs.slack-bot-token }}" \
            -H "Content-type: application/json" \
            -d "{
              \"channel\": \"#$CHANNEL_NAME\",
              \"text\": \"$MESSAGE_TEXT\"
            }" \
            "https://slack.com/api/chat.postMessage")
          
          # For new messages, extract the timestamp from the response
          if echo "$RESPONSE" | jq -e '.ok == true' > /dev/null; then
            FINAL_MESSAGE_TS=$(echo "$RESPONSE" | jq -r '.ts // empty')
            echo "üìù New message created with timestamp: $FINAL_MESSAGE_TS"
          else
            FINAL_MESSAGE_TS=""
            echo "‚ö†Ô∏è Could not extract timestamp from new message response"
          fi
        fi

        # Check if message was posted successfully
        SUCCESS=$(echo "$RESPONSE" | jq -r '.ok // false')
        if [ "$SUCCESS" = "true" ]; then
          echo "‚úÖ Slack notification posted successfully!"
        else
          ERROR=$(echo "$RESPONSE" | jq -r '.error // "unknown"')
          echo "‚ö†Ô∏è Slack notification failed: $ERROR"
          echo "üìã Full response: $RESPONSE"
          # Don't fail the entire step - just log the error
          echo "üîÑ Continuing despite Slack notification failure..."
        fi

        # Output the final message timestamp (either existing or newly created)
        echo "message_ts=$FINAL_MESSAGE_TS" >> $GITHUB_OUTPUT

        # Always exit successfully to prevent CI failure
        echo "‚úÖ Step completed successfully"
        exit 0
