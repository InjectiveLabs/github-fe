name: "Generate GitHub Release Notes"
description: "Generate GitHub release notes from git commits"

inputs:
  previous_tag:
    description: "The previous tag to compare against"
    required: true
  repo_url:
    description: "The URL of the repository"
    required: true

outputs:
  new_version:
    description: "Incremented github tag number"
    value: ${{ steps.increment_version.outputs.new_version }}
  release_notes:
    description: "Generated release notes from git commits"
    value: "${{ steps.generate_notes.outputs.release_notes }}"
  bugsnag_version:
    description: "The app version to use for Bugsnag"
    value: ${{ steps.compute_bugsnag_app_version.outputs.app_version }}

runs:
  using: "composite"
  steps:
    - name: Increment version
      id: increment_version
      shell: bash
      run: |
        # Remove 'v' prefix if present and split the version into major, minor, patch components
        tag_without_v="${{ inputs.previous_tag }}"
        tag_without_v="${tag_without_v#v}"
        IFS='.' read -r major minor patch <<< "$tag_without_v"

        # Validate that we have all three components
        if [[ -z "$major" || -z "$minor" || -z "$patch" ]]; then
          echo "Error: Invalid tag format. Expected format: v1.2.3 or 1.2.3"
          exit 1
        fi

        # Increment the patch number
        patch=$((patch + 1))
        new_version="v$major.$minor.$patch"
        echo "new_version=${new_version}" >> $GITHUB_ENV
        echo "new_version=${new_version}" >> $GITHUB_OUTPUT

    - name: Generate Release Notes
      id: generate_notes
      shell: bash
      run: |
        previous_tag="${{ inputs.previous_tag }}"
        repo_url="${{ inputs.repo_url }}"

        # Validate that the previous tag exists
        if ! git rev-parse --verify "$previous_tag" >/dev/null 2>&1; then
          echo "Error: Tag '$previous_tag' does not exist"
          exit 1
        fi

        # Debug: Show current HEAD and tag info
        echo "Previous tag: $previous_tag"
        echo "Current HEAD: $(git rev-parse HEAD)"
        echo "Tag commit: $(git rev-parse "$previous_tag")"

        # Get all commits in the range (excluding merge commits for cleaner output)
        echo "🔍 Running git command: git log \"$previous_tag\"..HEAD --no-merges --pretty=format:\"%H|%s|%an|%ae\""
        all_commits=$(git log "$previous_tag"..HEAD --no-merges --pretty=format:"%H|%s|%an|%ae" 2>/dev/null)

        # Count the actual commits we'll be processing (excluding merges)
        commit_count=$(echo "$all_commits" | wc -l)

        # Debug: Show total commit counts for comparison
        total_commits=$(git rev-list --count "$previous_tag"..HEAD 2>/dev/null || echo "0")
        echo "📊 Total commits (including merges): $total_commits"
        echo "📊 Regular commits (excluding merges): $commit_count"

        if [[ "$commit_count" -eq 0 ]]; then
          echo "No commits found between ${previous_tag} and HEAD."
          formatted_notes="No new commits"
        else
          echo "Found $commit_count commits between ${previous_tag} and HEAD (excluding merge commits)"
          
          # Debug: Show raw commit data
          echo "Raw commits found:"
          echo "$all_commits" | head -10
          
          formatted_notes=""

          # Process each commit using a more robust method
          if [[ -n "$all_commits" ]]; then
            echo "🔧 Starting commit processing..."
            
            # Use a temporary file to avoid subshell and newline issues
            temp_file=$(mktemp)
            echo "📁 Created temp file: $temp_file"
            printf "%s\n" "$all_commits" > "$temp_file"
            
            # Debug: Show temp file contents
            echo "📄 Temp file contents:"
            cat -n "$temp_file"
            
            commit_counter=0
            while IFS='|' read -r commit_hash commit_message commit_author commit_email; do
              commit_counter=$((commit_counter + 1))
              echo "🔄 Processing commit #$commit_counter: $commit_hash"
              echo "   Message: $commit_message"
              echo "   Author: $commit_author"
              echo "   Email: $commit_email"
              
              if [[ -n "$commit_hash" && -n "$commit_message" ]]; then
                echo "   ✅ Valid commit data, processing..."
                
                # Clean up commit message (escape backticks and quotes)
                commit_message=$(echo "$commit_message" | sed 's/`/\\`/g' | sed 's/"/\\"/g')
                echo "   🧹 Cleaned message: $commit_message"
                
                # Format author
                if [[ "$commit_author" =~ " " ]]; then
                  github_author="${commit_author} (${commit_email})"
                else
                  github_author="@${commit_author}"
                fi
                echo "   👤 Formatted author: $github_author"
                
                # Check if this commit message contains a PR number
                echo "   🔍 Checking for PR number..."
                pr_info=""
                echo "   🔍 Running grep command on: '$commit_message'"
                set +e  # Disable exit on error temporarily
                pr_number=$(echo "$commit_message" | grep -oE "#[0-9]+" | head -1)
                grep_exit_code=$?
                set -e  # Re-enable exit on error
                echo "   🔍 Grep exit code: $grep_exit_code"
                echo "   🔍 PR number result: '$pr_number'"
                if [[ -n "$pr_number" ]]; then
                  echo "   🔍 PR number found, creating link..."
                  pr_link="[${pr_number}](${repo_url}/pull/${pr_number:1})"
                  pr_info=" in ${pr_link}"
                  echo "   🔗 Found PR: $pr_number"
                else
                  echo "   🔍 No PR number found"
                fi
                
                # Add to formatted notes
                echo "   📝 Adding to formatted notes..."
                old_notes="$formatted_notes"
                echo "   📝 Old notes length: ${#old_notes}"
                echo "   📝 Creating new note entry..."
                new_entry="- ${commit_hash:0:7} - ${commit_message} by ${github_author}${pr_info}"
                echo "   📝 New entry: $new_entry"
                formatted_notes="${formatted_notes}\n${new_entry}"
                echo "   📝 Added to notes. Length before: ${#old_notes}, after: ${#formatted_notes}"
              else
                echo "   ❌ Invalid commit data, skipping..."
              fi
            done < "$temp_file"
            
            echo "🏁 Finished processing $commit_counter commits"
            echo "📊 Final formatted_notes length: ${#formatted_notes}"
            
            # Clean up temporary file
            rm -f "$temp_file"
            echo "🗑️ Cleaned up temp file"
          else
            echo "No commits found in the specified range"
          fi
        fi

        if [[ -z "$formatted_notes" ]]; then
          formatted_notes="No new commits"
        fi

        # Export the formatted notes to the GitHub environment
        echo "release_notes<<EOF" >> $GITHUB_OUTPUT
        echo -e "${formatted_notes}" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Compute Bugsnag App Version
      id: compute_bugsnag_app_version
      shell: bash
      run: |
        # Assign new_version from earlier step output to a shell variable
        new_version="${{ steps.increment_version.outputs.new_version }}"
        release_notes="${{ steps.generate_notes.outputs.release_notes }}"

        # Initialize app_version with new_version
        app_version="$new_version"

        # Conditional assignment based on release_notes output
        if [[ "$release_notes" == "No new commits" ]]; then
          app_version="${{ inputs.previous_tag }}"
        fi

        # Set the app_version as an output
        echo "app_version=$app_version" >> $GITHUB_OUTPUT

        # Log for debug purposes
        echo "Release notes: $release_notes"
        echo "Bugsnag version: $app_version"
