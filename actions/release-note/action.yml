name: "Generate GitHub Release Notes"
description: "Generate GitHub release notes from git commits"

inputs:
  previous_tag:
    description: "The previous tag to compare against"
    required: true
  repo_url:
    description: "The URL of the repository"
    required: true

outputs:
  new_version:
    description: "Incremented github tag number"
    value: ${{ steps.increment_version.outputs.new_version }}
  release_notes:
    description: "Generated release notes from git commits"
    value: "${{ steps.generate_notes.outputs.release_notes }}"
  bugsnag_version:
    description: "The app version to use for Bugsnag"
    value: ${{ steps.compute_bugsnag_app_version.outputs.app_version }}

runs:
  using: "composite"
  steps:
    - name: Increment version
      id: increment_version
      shell: bash
      run: |
        # Remove 'v' prefix if present and split the version into major, minor, patch components
        tag_without_v="${{ inputs.previous_tag }}"
        tag_without_v="${tag_without_v#v}"
        IFS='.' read -r major minor patch <<< "$tag_without_v"

        # Validate that we have all three components
        if [[ -z "$major" || -z "$minor" || -z "$patch" ]]; then
          echo "Error: Invalid tag format. Expected format: v1.2.3 or 1.2.3"
          exit 1
        fi

        # Increment the patch number
        patch=$((patch + 1))
        new_version="v$major.$minor.$patch"
        echo "new_version=${new_version}" >> $GITHUB_ENV
        echo "new_version=${new_version}" >> $GITHUB_OUTPUT

    - name: Generate Release Notes
      id: generate_notes
      shell: bash
      run: |
        previous_tag="${{ inputs.previous_tag }}"
        repo_url="${{ inputs.repo_url }}"

        # Validate that the previous tag exists
        if ! git rev-parse --verify "$previous_tag" >/dev/null 2>&1; then
          echo "Error: Tag '$previous_tag' does not exist"
          exit 1
        fi

        # Step 1: Find the commit with the previous tag and get its date
        echo "=== STEP 1: Finding previous tag commit date ==="
        echo "Looking for tag: $previous_tag"
        tag_commit_date=$(git log -1 --format="%ct" "$previous_tag" 2>/dev/null)

        if [[ -z "$tag_commit_date" ]]; then
          echo "Error: Could not get commit date for tag '$previous_tag'"
          exit 1
        fi

        echo "‚úì Previous tag '$previous_tag' commit date: $tag_commit_date"
        echo ""

        # Step 2: Fetch commits that happened after the tag commit date
        echo "=== STEP 2: Fetching commits after tag commit date ==="
        echo "Command: git log master --since=\"$tag_commit_date\" --pretty=format:\"%H|%ct|%s|%an|%ae\""

        # Initialize variables
        commit_count=0
        excluded_count=0
        formatted_notes=""

        # Fetch commits - handle empty result gracefully
        set +e  # Disable exit on error for git log
        all_commits=$(git log master --since="$tag_commit_date" --pretty=format:"%H|%ct|%s|%an|%ae" 2>/dev/null)
        git_log_exit_code=$?
        set -e  # Re-enable exit on error

        # Check if git log found any commits
        if [[ "$git_log_exit_code" -ne 0 ]]; then
          echo "‚ö† Warning: git log command exited with code $git_log_exit_code"
        fi

        if [[ -n "$all_commits" ]]; then
          # Count lines safely - handle empty input
          commit_lines=$(printf "%s\n" "$all_commits" | wc -l | tr -d ' ')
          echo "‚úì Found $commit_lines commits in git log output"
        else
          echo "‚ö† No commits found in git log output"
          commit_lines=0
        fi
        echo ""

        # Step 3: Filter commits by actual commit date and process them
        echo "=== STEP 3: Filtering and processing commits ==="
        first_commit=true

        if [[ -n "$all_commits" ]]; then
          # Use a temporary file to avoid subshell and newline issues
          temp_file=$(mktemp)
          trap "rm -f '$temp_file'" EXIT  # Ensure temp file is cleaned up
          printf "%s\n" "$all_commits" > "$temp_file"
          
          echo "Processing commits:"
          while IFS='|' read -r commit_hash commit_date commit_message commit_author commit_email || [[ -n "$commit_hash" ]]; do
            # Skip empty lines
            if [[ -z "$commit_hash" && -z "$commit_message" ]]; then
              continue
            fi
            
            if [[ -n "$commit_hash" && -n "$commit_message" && -n "$commit_date" ]]; then
              # Skip the first commit (which is the previous tag commit itself)
              if [[ "$first_commit" == "true" ]]; then
                echo "  üö´ Excluding previous tag commit: ${commit_hash:0:7} - $commit_message"
                first_commit=false
                excluded_count=$((excluded_count + 1))
                continue
              fi
              
              # Only include commits that were created after the tag commit date
              if [[ "$commit_date" -gt "$tag_commit_date" ]]; then
                commit_count=$((commit_count + 1))
                echo "  ‚úÖ Including commit ${commit_count}: ${commit_hash:0:7} (date: $commit_date) - $commit_message"
                
                # Clean up commit message (escape backticks and quotes)
                commit_message=$(echo "$commit_message" | sed 's/`/\\`/g' | sed 's/"/\\"/g')
                
                # Format author
                if [[ "$commit_author" =~ " " ]]; then
                  github_author="${commit_author} (${commit_email})"
                else
                  github_author="@${commit_author}"
                fi
                
                # Check if this commit message contains a PR number
                pr_info=""
                set +e  # Disable exit on error temporarily
                pr_number=$(echo "$commit_message" | grep -oE "#[0-9]+" | head -1)
                set -e  # Re-enable exit on error
                if [[ -n "$pr_number" ]]; then
                  pr_link="[${pr_number}](${repo_url}/pull/${pr_number:1})"
                  pr_info=" in ${pr_link}"
                fi
                
                # Create clickable commit link
                commit_link="[${commit_hash:0:7}](${repo_url}/commit/${commit_hash})"
                
                # Add to formatted notes
                formatted_notes="${formatted_notes}\n- ${commit_link} - ${commit_message} by ${github_author}${pr_info}"
              else
                echo "  ‚è∞ Excluding old commit: ${commit_hash:0:7} (date: $commit_date) - $commit_message"
                excluded_count=$((excluded_count + 1))
              fi
            fi
          done < "$temp_file"
          
          # Clean up temporary file
          rm -f "$temp_file"
          trap - EXIT  # Remove trap
        else
          echo "No commits to process"
        fi

        echo ""
        echo "=== FILTERING SUMMARY ==="
        echo "‚úì Commits included: $commit_count"
        echo "üö´ Commits excluded: $excluded_count"
        echo ""

        # Set formatted_notes to "No new commits" if no commits were found
        if [[ "$commit_count" -eq 0 ]]; then
          formatted_notes="No new commits"
        fi

        # Echo the formatted notes
        echo "=== FINAL OUTPUT ==="
        echo "Generated release notes:"
        echo -e "${formatted_notes}"
        echo ""

        # Export the formatted notes to the GitHub environment
        # Use printf to ensure consistent output format
        printf "release_notes<<EOF\n" >> $GITHUB_OUTPUT
        printf "%s\n" "$formatted_notes" >> $GITHUB_OUTPUT
        printf "EOF\n" >> $GITHUB_OUTPUT

    - name: Compute Bugsnag App Version
      id: compute_bugsnag_app_version
      shell: bash
      run: |
        # Assign new_version from earlier step output to a shell variable
        new_version="${{ steps.increment_version.outputs.new_version }}"
        release_notes="${{ steps.generate_notes.outputs.release_notes }}"

        # Initialize app_version with new_version
        app_version="$new_version"

        # Conditional assignment based on release_notes output
        if [[ "$release_notes" == "No new commits" ]]; then
          app_version="${{ inputs.previous_tag }}"
        fi

        # Set the app_version as an output
        echo "app_version=$app_version" >> $GITHUB_OUTPUT
